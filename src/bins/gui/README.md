<!--
 Copyright (c) 2022 Tony Barbitta
 
 This Source Code Form is subject to the terms of the Mozilla Public
 License, v. 2.0. If a copy of the MPL was not distributed with this
 file, You can obtain one at http://mozilla.org/MPL/2.0/.
-->

# Noted - Gui Code

This is my first foray into using the (very awesome) `egui` crate. So far here is what is going on:
- `./backend/` - This backend structs lives on a separate thread from the UI and handles the database management. It converses with the frontend using the messages described by the `ToFrontend` and `ToBackend` enums in `./backend/msg.rs`.
- `./widgets/` - This probably needs a better name, but is currently the place I'm keeping any front-end "components" in `react` terms, including the `screen_prompt.rs` file I shameless stole/borrowed from the very helpful [`mCubed repository`](https://github.com/4JX/mCubed/blob/77b646385d6be0e30885ae95e656a60a601ac120/main/src/ui/widgets/screen_prompt.rs). I have not actually tried to use the screen prompt, I think out of fear which is an odd feeling indeed, but it is planned to be used for things like "Are you sure you want to delete this note?", as I don't like the idea of having a "delete this note" command be permanent with no options for undo.
    - `/list.rs` - The `NoteList` struct that is responsible for displaying the list of notes in the `GuiApp` `egui::SidePanel`
    - `/msg.rs` - The messages that are used by front-end components to communicate. Each "widget" that needs to send app messages receives and stores an instance of `crossbeam_channel::Sender<ToApp>` used to send any necessary messages to the `GuiApp` instance. This includes things like `NoteList` sending a message requesting the deletion of a note (`ToApp::DeleteActiveNote` or `ToApp::DeleteNote(Note)`), or settings a new active note (`ToApp::SetActiveNote(Note)`). This seems like a pretty nice way of handling communication while only having to deal with one-directional references / ownership (`GuiApp` holds a reference to the components used, but not vice versa) which means that all components, including `GuiApp` are free to use `&mut self` as needed.
    - `/note_editor.rs` - Holds the `NoteEditor` component, responsible for rendering the `Note` editor that makes up the main `egui::CentralPanel`. Sends `ToApp::CreateNewNote`. Previously I had the backend `Database` being updated on every change made to a note that was being edited, but now this type exposes a public `NoteEditor::has_changes` function that can be polled to check if there are any changes that need to be transmitted to the backend.
    - `/screen_prompt.rs` - The aforementioned full screen prompt type stolen from the [`mCubed repository`](https://github.com/4JX/mCubed). Currently unused as the much simpler prompt in `simple_prompt.rs` was a better fit for my use-case (confirm deletion prompts). The `mCubed` app uses the `ScreenPrompt` type for a full screen "pop-up" (but is more accurately described as a full window overlay) settings editor.
    - `/simple_prompt.rs` - A very simple pop-up prompt modeled after the code found in the `egui` "confirm_exit" example. Works perfectly for simple "Yes/No" or "Yes/No/Cancel" prompts.
    - `/toaster.rs` - I was going to manually write a "toast"/notification system, which I fully believe I could do, but I have finally gotten the `egui_toast` library to work (see `GuiApp::render_toasts` as well as the `GuiApp::toast_rx`/`GuiApp::toast_tx` channels). 
- `./app.rs` - Currently this holds almost all of the active frontend / ui code. **This is terrible and needs to be addressed ASAP before it gets too much more out of hand**. Here are my current observations for parts that can be extracted:
    - [x] Right now the `GuiApp` type has fields and many functions that are dedicated solely to tracking the "current active item being modified". While this is unavoidable due to the nature of immediate mode gui, I think a good candidate for extraction is a `NoteEditor`, so that the main `GuiApp` is not weighed down by the minutiae of tracking these details.
- `./hotkey.rs` - Holds the following types: the `Hotkeys` type which currently holds **fixed** references to application wide hotkeys through the use of `egui_hotkey` crate; the `HotkeyState` struct which is a simple POD type with boolean values indicated if any of the `Hotkeys` were pressed (created by `Hotkeys::check_hotkeys` function); the stateless `HotkeyEditor` type which is responsible for rendering a screen for viewing and (eventually) changing the current hotkeys. Unfortunately it seems like it will need some sort of state so that I can actually enable editing of the hotkeys. The `egui_hotkey` crate handles the mechanics behind this, I just need to integrate it appropriately. 
- `./mod.rs` - The module file which contains the entry function that is called by the `gui` bin.
- `./settings.rs` - The application / gui settings (`AppSettings`) that are used and saved by the app, as well as the `AppSettingsUi` which is a stateless struct that holds a function which renders the settings screen/panel in the ui. Currently, the `AppSettings` struct will look for a file in the project directory (as determined by the `directories` crate), and if it is not found a default will be created. This is probably an over-reach as far as responsibility and will likely change in the future.
- `./theme.rs` - Another shameless copy from the very informative [`mCubed repo`](https://github.com/4JX/mCubed/blob/master/main/src/ui/app_theme.rs). I am not currently using this at all but have added it to my project as a starting point for when I start adding customized colors and whatnot.

Here is my (probably hefty) todolist:
- [ ] Start breaking down `app.rs` into multiple smaller "components" so that I don't have 20,000,000 methods all contained in one gigantic ui struct. First I need to decide on the best way to organize and handle the UI, now that I'm *starting* to get a better feel for the immediate mode gui style.
- [ ] Look at the message passing implementation and handling, see if there's a way to make it better.
- [x] I have attempted to add notifications/toasts to the gui using the `egui_toast` crate, but could not get the integration to work (and subsequently deleted the code). ~~I think I might know enough about `egui` at this point to implement my own very simplistic system for notifications, so lets take a crack at that.~~ I have gotten the `egui_toast` crate to work.
- [ ] I would like to look into implementing an undo-redo system (along with a trash-can / recycling bin type functionality). I **do** like that all data is saved in real-time, as it makes the app less likely to lose important things due an unexpected sudden termination, but having the option to undo and redo changes would be beneficial. I'm currently unsure if this should be something that is handled by the `crate::db::Database`, or if it should be an outside "monitoring" situation, but either way will require changes to the database type. From the start I have wanted to include change-tracking and change-logs into the Database type so these would go hand-in-hand and might be a good motivator to get that portion completed. 
- [ ] While the GUI is working, there are many things that I am currently doing in a very ugly and hopefully temporary way. These need to be done better. I'll try to list these here as I come across / think of them:
    - [x] The note list side panel, currently each clickable note header is displayed as a button that is as big as the title text, I would like these to all be uniformly the same size, regardless of text length.
    - [x] Today (05/24/22) I added the `ExitState` enum and corresponding `GuiApp::exit_state` field on the main app struct, and while it is working as expected, this needs to be cleaned up and hopefully handled in a better way. ~~Also, right now I am not honoring the `AppSettings::autosave_enabled` setting. I feel like changing this will open a whole can of worms which will lead to further issues. Currently any changes in a single note are written to the in-memory database in real time, this process could probably be batched for better performance, but might lead to more duplication between front and back end data.~~ I am now honoring the autosave setting. `GuiApp` now has two functions related to saving, `GuiApp::autosave` and `GuiApp::save_data`. The first is called on the `eframe::App::save` function and checks whether autosave is enabled before calling the actual `GuiApp::save_data` function which directly saves the data. Working very well so far.
    - [ ] App-wide controls, including the settings button, an option to close and open a different note database, and perhaps a light-dark toggle button. Currently I have a bottom panel which is serving as an error log for any backend error messages so that they are not silently swallowed due to being in a separate thread. Luckily this gave me an opportunity to add a settings button, but I need a better place to store these app-wide controls. Perhaps a menu-bar along the top?
- [ ] I think perhaps I should factor the "tag list editor" portion of `NoteEditor` into it's own type now that I am using *very* similar code inside of the `Reminder` list editor within the same type. Plus it seems like a no brainer to have such functionality be available on a more general level.